import{_ as e,o as l,c as i,ah as r}from"./chunks/framework.BBZ3KW63.js";const p=JSON.parse('{"title":"浏览器输入url之后发生了什么？","description":"","frontmatter":{},"headers":[],"relativePath":"webNet/浏览器流程.md","filePath":"webNet/浏览器流程.md"}'),t={name:"webNet/浏览器流程.md"};function h(d,a,s,o,n,c){return l(),i("div",null,[...a[0]||(a[0]=[r('<h1 id="浏览器输入url之后发生了什么" tabindex="-1">浏览器输入url之后发生了什么？ <a class="header-anchor" href="#浏览器输入url之后发生了什么" aria-label="Permalink to “浏览器输入url之后发生了什么？”">​</a></h1><h2 id="url" tabindex="-1">URL <a class="header-anchor" href="#url" aria-label="Permalink to “URL”">​</a></h2><p><a href="http://www.billibili.com/dir/file1.html" target="_blank" rel="noreferrer">http://www.billibili.com/dir/file1.html</a></p><ul><li>http就是访问协议，</li><li>www.billibili.com是域名（也有直接用ip地址的），</li><li>dir：目录名</li><li>file1.html：文件名</li></ul><h2 id="dns查询" tabindex="-1">DNS查询 <a class="header-anchor" href="#dns查询" aria-label="Permalink to “DNS查询”">​</a></h2><p>一般服务器是有ip但是比较抽象所以有了域名，就是这个域名可以映射到这个服务器ip。就是你给DNS这个域名他直接帮你找到这个ip <strong>DNS查询</strong>可以从域名解读到服务器ip</p><h3 id="dns查询顺序" tabindex="-1">DNS查询顺序 <a class="header-anchor" href="#dns查询顺序" aria-label="Permalink to “DNS查询顺序”">​</a></h3><p>其中一个成功，就直接跳到地址</p><ul><li>浏览器自身DNS</li><li>操作系统DNS</li><li>本地host文件</li><li>向域名服务器发送请求</li></ul><h3 id="dns查找规则" tabindex="-1">DNS查找规则 <a class="header-anchor" href="#dns查找规则" aria-label="Permalink to “DNS查找规则”">​</a></h3><p>先向本地DNS服务器中寻找，如果没有那就按这个顺序寻找(括号是示例)： 1、根域名服务器(.)-&gt;2、顶级域名服务器(com.)-&gt;3、权威域名服务器(baidu.com.) 找到ip之后就发送请求了</p><h2 id="七层网络模型" tabindex="-1">七层网络模型 <a class="header-anchor" href="#七层网络模型" aria-label="Permalink to “七层网络模型”">​</a></h2><p>发送请求 发送http请求，要遵循报文格式</p><h2 id="浏览器的缓存" tabindex="-1">浏览器的缓存 <a class="header-anchor" href="#浏览器的缓存" aria-label="Permalink to “浏览器的缓存”">​</a></h2><h3 id="强缓存-让浏览器强制缓存服务器提供的资源" tabindex="-1">强缓存：让浏览器强制缓存服务器提供的资源 <a class="header-anchor" href="#强缓存-让浏览器强制缓存服务器提供的资源" aria-label="Permalink to “强缓存：让浏览器强制缓存服务器提供的资源”">​</a></h3><p>请求头里可以设置两个字段来设置缓存时间 1.Cache-Control:max-age=10 (强制缓存十秒) [这个优先级更高] 2.Expires:Wed,21 ..... (缓存到指定时间)</p><ul><li>from disk cache:硬盘缓存</li><li>from memory cache:内存缓存</li></ul><h3 id="协商缓存-一些缓存已经过期-但是资源没有改变-于是浏览器使用这个缓存返回304-如果资源改变-那么返回200同时带上最新资源" tabindex="-1">协商缓存：一些缓存已经过期，但是资源没有改变，于是浏览器使用这个缓存返回304，如果资源改变，那么返回200同时带上最新资源 <a class="header-anchor" href="#协商缓存-一些缓存已经过期-但是资源没有改变-于是浏览器使用这个缓存返回304-如果资源改变-那么返回200同时带上最新资源" aria-label="Permalink to “协商缓存：一些缓存已经过期，但是资源没有改变，于是浏览器使用这个缓存返回304，如果资源改变，那么返回200同时带上最新资源”">​</a></h3><h4 id="last-modified实现" tabindex="-1">Last-Modified实现 <a class="header-anchor" href="#last-modified实现" aria-label="Permalink to “Last-Modified实现”">​</a></h4><ul><li><p>Last-Modified：GMT时间（最后被修改的时间）</p></li><li><p>if-Modified-since: GMT时间 如果这两个时间相同，那不就表示资源没有改变吗?不过我看这个被吐槽的时一秒还是太长了，这是为啥？因为请求都是毫秒级的</p></li><li><p>比如一个被频繁访问的API端点，如果在一秒内被多个客户端请求，而资源在这期间更新了，那么Last-Modified就无法准确反映这种变化。</p></li></ul><h4 id="etag实现-相当于文件标志" tabindex="-1">Etag实现（相当于文件标志） <a class="header-anchor" href="#etag实现-相当于文件标志" aria-label="Permalink to “Etag实现（相当于文件标志）”">​</a></h4><ul><li>Etag:&quot;djalksndklasndlk&quot; (假设是文件hash，也可以有其他的东西)</li><li>if-None-Match:&quot;dhjaklsldldada&quot; 如果这两个标识不同，那就表示更新了</li></ul><h2 id="tcp断开连接" tabindex="-1">TCP断开连接 <a class="header-anchor" href="#tcp断开连接" aria-label="Permalink to “TCP断开连接”">​</a></h2><h2 id="渲染html页面" tabindex="-1">渲染HTML页面 <a class="header-anchor" href="#渲染html页面" aria-label="Permalink to “渲染HTML页面”">​</a></h2><h3 id="解析器将html解析成dom树-css解析成stylesheets然后计算dom节点的样式" tabindex="-1">解析器将html解析成DOM树，css解析成styleSheets然后计算DOM节点的样式 <a class="header-anchor" href="#解析器将html解析成dom树-css解析成stylesheets然后计算dom节点的样式" aria-label="Permalink to “解析器将html解析成DOM树，css解析成styleSheets然后计算DOM节点的样式”">​</a></h3><h3 id="绘制页面-回流重绘" tabindex="-1">绘制页面：回流重绘 <a class="header-anchor" href="#绘制页面-回流重绘" aria-label="Permalink to “绘制页面：回流重绘”">​</a></h3><p>回流：一些操作会导致DOM节点的大小和属性和文档流的位置有变化，浏览器就会重新渲染 重绘：颜色的改变等，浏览器将样式给元素并且重新绘制</p><h3 id="js" tabindex="-1">js <a class="header-anchor" href="#js" aria-label="Permalink to “js”">​</a></h3><p>使用v8引擎解析</p>',29)])])}const b=e(t,[["render",h]]);export{p as __pageData,b as default};
