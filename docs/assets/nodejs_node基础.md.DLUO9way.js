import{_ as n,o as e,c as a,ah as p}from"./chunks/framework.BBZ3KW63.js";const u=JSON.parse('{"title":"指令","description":"","frontmatter":{},"headers":[],"relativePath":"nodejs/node基础.md","filePath":"nodejs/node基础.md"}'),t={name:"nodejs/node基础.md"};function i(o,s,l,c,d,r){return e(),a("div",null,[...s[0]||(s[0]=[p(`<h1 id="指令" tabindex="-1">指令 <a class="header-anchor" href="#指令" aria-label="Permalink to “指令”">​</a></h1><p>npm install npm config list npm get registry npm login npm publish -g 是全局安装，就是安装到你本地了，下次要用的时候，可以直接在本地引入 --save <strong>-dev</strong> 是安装到开发者依赖里面</p><p>三个依赖的不同：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span></span></span>
<span class="line"><span>&quot;dependencies&quot;: {</span></span>
<span class="line"><span>        &quot;md5&quot;: &quot;^2.3.0&quot;</span></span>
<span class="line"><span>      },</span></span>
<span class="line"><span>      &quot;devDependencies&quot;: {</span></span>
<span class="line"><span>        &quot;webpack&quot;: &quot;^5.105.0&quot;</span></span>
<span class="line"><span>      },</span></span>
<span class="line"><span>      &quot;peerDependencies&quot;:{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      }</span></span></code></pre></div><p><strong>dependencies</strong>是开发和生产都要用的依赖，比如vue，做出来的网页都要用 <strong>devDependencies</strong>是开发依赖，比如说webpack，只用来打包的 <strong>peerDependencies</strong>是同辈依赖，意思是什么呢？比如使用vue，它里面用到了其他依赖，那你安装了使用vue，这里也应该安装一下</p><p>npx大概的意思是，原本使用包需要你npm下载下来，而npx可以在下载后删除然后使用</p><p>模块化 nodejs也有模块化的，但是分两种：commonjs和es6（module）的，在这个package.json配置一下type就能选择 commonjs： 支持五种模式 1、引入自己编写的模块 require(&#39;./print.js&#39;); 2、引入下载的模块 const md5 = require(&#39;md5&#39;); console.log(md5(1234567)); //498001217bc632cb158588224d7d23c4 3、引入node的内置模块 fs 等等 const fs = require(&#39;node:fs&#39;) //高版本可以用node:fs做一个区分作用 const txt = fs.readFileSync(&#39;./a.txt&#39;).toString(); console.log(txt); 4、引入c++模块 5、引入json文件 const json = require(&#39;./data.json&#39;); console.log(json);</p><p>module呢就不支持c++了，而且动态加载需要用函数的方式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>if(true){</span></span>
<span class="line"><span>    import(&#39;./test.js&#39;).then(res=&gt;{</span></span>
<span class="line"><span>        console.log(res);</span></span>
<span class="line"><span>        </span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>两者的不同： Cjs是基于运行时的同步加载，esm是基于编译时的异步加载 Cjs是可以修改值的，esm值并且不可修改（可读的） Cjs不可以tree shaking，esm支持tree shaking commonjs中顶层的this指向这个模块本身，而ES6中顶层this指向undefined</p><p>发布的时候，在package.json里面可以定义要发布的文件</p>`,11)])])}const h=n(t,[["render",i]]);export{u as __pageData,h as default};
